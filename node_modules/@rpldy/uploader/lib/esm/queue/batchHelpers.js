function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { BATCH_STATES, logger, merge, FILE_STATES } from "@rpldy/shared";
import { unwrap } from "@rpldy/simple-state";
import { UPLOADER_EVENTS } from "../consts";
var BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];
var BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED];

var getBatchFromState = function (state, id) {
  return state.batches[id].batch;
};

var getBatch = function (queue, id) {
  return getBatchFromState(queue.getState(), id);
};

var isItemBelongsToBatch = function (queue, itemId, batchId) {
  return queue.getState().items[itemId].batchId === batchId;
};

var getBatchDataFromItemId = function (queue, itemId) {
  var state = queue.getState();
  var item = state.items[itemId];
  return state.batches[item.batchId];
};

var getBatchFromItemId = function (queue, itemId) {
  return getBatchDataFromItemId(queue, itemId).batch;
};

var removeBatchItems = function (queue, batchId) {
  var batch = getBatch(queue, batchId);
  queue.updateState(function (state) {
    batch.items.forEach(function (_ref) {
      var id = _ref.id;
      delete state.items[id];
      var index = state.itemQueue.indexOf(id);

      if (~index) {
        state.itemQueue.splice(index, 1);
      }
    });
  });
};

var removeBatch = function (queue, batchId) {
  queue.updateState(function (state) {
    delete state.batches[batchId];
  });
};

var cancelBatchForItem = function (queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId),
      batchId = batch.id;
  logger.debugLog("uploady.uploader.batchHelpers: cancelling batch: ", {
    batch: batch
  });
  queue.updateState(function (state) {
    var batch = getBatchFromState(state, batchId);
    batch.state = BATCH_STATES.CANCELLED;
  });
  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};

var isNewBatchStarting = function (queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId);
  return queue.getState().currentBatch !== batch.id;
};

var loadNewBatchForItem = function (queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId);
  return queue.runCancellable(UPLOADER_EVENTS.BATCH_START, batch).then(function (isCancelled) {
    if (!isCancelled) {
      queue.updateState(function (state) {
        state.currentBatch = batch.id;
      });
    }

    return !isCancelled;
  });
};

var cleanUpFinishedBatches = function (queue) {
  //TODO: schedule clean up on requestAnimationFrame
  var state = queue.getState();
  Object.keys(state.batches).forEach(function (batchId) {
    var _state$batches$batchI = state.batches[batchId],
        batch = _state$batches$batchI.batch,
        finishedCounter = _state$batches$batchI.finishedCounter;
    var orgItemCount = batch.orgItemCount; //shouldnt be the case, but if wasnt cleaned before, it will now

    var alreadyFinalized = getIsBatchFinalized(batch);

    if (orgItemCount === finishedCounter) {
      queue.updateState(function (state) {
        var batch = getBatchFromState(state, batchId); //set batch state to FINISHED before triggering event and removing it from queue

        batch.state = alreadyFinalized ? batch.state : BATCH_STATES.FINISHED;

        if (state.currentBatch === batchId) {
          state.currentBatch = null;
        }
      });
      logger.debugLog("uploady.uploader.batchHelpers: cleaning up batch: ".concat(batch.id));

      if (!alreadyFinalized) {
        triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);
      }

      removeBatchItems(queue, batchId);
      removeBatch(queue, batchId);
    }
  });
};

var triggerUploaderBatchEvent = function (queue, batchId, event) {
  var state = queue.getState(),
      batch = getBatchFromState(state, batchId),
      //get the most uptodate batch data
  stateItems = state.items;

  var eventBatch = _objectSpread(_objectSpread({}, unwrap(batch)), {}, {
    items: batch.items.map(function (_ref2) {
      var id = _ref2.id;
      return unwrap(stateItems[id]);
    })
  });

  queue.trigger(event, eventBatch);
};

var getIsItemBatchReady = function (queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId);
  return BATCH_READY_STATES.includes(batch.state);
};

var detachRecycledFromPreviousBatch = function (queue, item) {
  var previousBatch = item.previousBatch;

  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {
    var _getBatchFromItemId = getBatchFromItemId(queue, item.id),
        batchId = _getBatchFromItemId.id;

    if (batchId === previousBatch) {
      queue.updateState(function (state) {
        var batch = getBatchFromState(state, batchId);
        var index = batch.items.findIndex(function (_ref3) {
          var id = _ref3.id;
          return id === item.id;
        });

        if (~index) {
          batch.items.splice(index, 1);
        }
      });
    }
  }
};

var preparePendingForUpload = function (queue, uploadOptions) {
  queue.updateState(function (state) {
    //remove pending state from pending batches
    Object.keys(state.batches).forEach(function (batchId) {
      var batchData = state.batches[batchId];
      var batch = batchData.batch,
          batchOptions = batchData.batchOptions;

      if (batch.state === BATCH_STATES.PENDING) {
        batch.items.forEach(function (item) {
          item.state = FILE_STATES.ADDED;
        });
        batch.state = BATCH_STATES.ADDED;
        batchData.batchOptions = merge({}, batchOptions, uploadOptions);
      }
    });
  });
};

var removePendingBatches = function (queue) {
  var batches = queue.getState().batches;
  Object.keys(batches).filter(function (batchId) {
    return batches[batchId].batch.state === BATCH_STATES.PENDING;
  }).forEach(function (batchId) {
    removeBatchItems(queue, batchId);
    removeBatch(queue, batchId);
  });
};

var incrementBatchFinishedCounter = function (queue, batchId) {
  queue.updateState(function (state) {
    state.batches[batchId].finishedCounter += 1;
  });
};

var getIsBatchFinalized = function (batch) {
  return BATCH_FINISHED_STATES.includes(batch.state);
};

export { loadNewBatchForItem, isNewBatchStarting, cancelBatchForItem, getBatchFromItemId, isItemBelongsToBatch, getBatchDataFromItemId, cleanUpFinishedBatches, triggerUploaderBatchEvent, getIsItemBatchReady, getBatchFromState, detachRecycledFromPreviousBatch, preparePendingForUpload, removePendingBatches, incrementBatchFinishedCounter, getIsBatchFinalized };